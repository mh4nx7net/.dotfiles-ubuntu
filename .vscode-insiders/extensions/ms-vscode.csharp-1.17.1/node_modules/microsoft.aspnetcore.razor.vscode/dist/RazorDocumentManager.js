"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const vscode = __importStar(require("vscode"));
const RazorDocumentChangeKind_1 = require("./RazorDocumentChangeKind");
const RazorDocumentFactory_1 = require("./RazorDocumentFactory");
const RazorLanguage_1 = require("./RazorLanguage");
const UriPaths_1 = require("./UriPaths");
const globbingPath = `**/*.${RazorLanguage_1.RazorLanguage.fileExtension}`;
class RazorDocumentManager {
    constructor(serverClient, logger) {
        this.serverClient = serverClient;
        this.logger = logger;
        this.razorDocuments = {};
        this.onChangeEmitter = new vscode.EventEmitter();
    }
    get onChange() { return this.onChangeEmitter.event; }
    get documents() {
        return Object.values(this.razorDocuments);
    }
    getDocument(uri) {
        return __awaiter(this, void 0, void 0, function* () {
            const document = this._getDocument(uri);
            yield this.ensureProjectedDocumentsOpen(document);
            return document;
        });
    }
    getActiveDocument() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!vscode.window.activeTextEditor) {
                return null;
            }
            if (vscode.window.activeTextEditor.document.languageId !== RazorLanguage_1.RazorLanguage.id) {
                return null;
            }
            const activeDocument = yield this.getDocument(vscode.window.activeTextEditor.document.uri);
            return activeDocument;
        });
    }
    initialize() {
        return __awaiter(this, void 0, void 0, function* () {
            // Track current documents
            const documentUris = yield vscode.workspace.findFiles(globbingPath);
            for (const uri of documentUris) {
                this.addDocument(uri);
            }
            const activeRazorDocument = yield this.getActiveDocument();
            if (activeRazorDocument) {
                // Initialize the html buffer for the current document
                this.updateHtmlBuffer(activeRazorDocument);
            }
            for (const textDocument of vscode.workspace.textDocuments) {
                if (textDocument.languageId !== RazorLanguage_1.RazorLanguage.id) {
                    continue;
                }
                this.openDocument(textDocument.uri);
            }
        });
    }
    register() {
        // Track future documents
        const watcher = vscode.workspace.createFileSystemWatcher(globbingPath);
        const didCreateRegistration = watcher.onDidCreate((uri) => __awaiter(this, void 0, void 0, function* () { return this.addDocument(uri); }));
        const didDeleteRegistration = watcher.onDidDelete((uri) => __awaiter(this, void 0, void 0, function* () { return this.removeDocument(uri); }));
        const didOpenRegistration = vscode.workspace.onDidOpenTextDocument(document => {
            if (document.languageId !== RazorLanguage_1.RazorLanguage.id) {
                return;
            }
            this.openDocument(document.uri);
        });
        const didCloseRegistration = vscode.workspace.onDidCloseTextDocument(document => {
            if (document.languageId !== RazorLanguage_1.RazorLanguage.id) {
                return;
            }
            this.closeDocument(document.uri);
        });
        const didChangeRegistration = vscode.workspace.onDidChangeTextDocument((args) => __awaiter(this, void 0, void 0, function* () {
            if (args.document.languageId !== RazorLanguage_1.RazorLanguage.id) {
                return;
            }
            this.documentChanged(args.document.uri);
        }));
        this.serverClient.onRequest('updateCSharpBuffer', updateBufferRequest => this.updateCSharpBuffer(updateBufferRequest));
        return vscode.Disposable.from(watcher, didCreateRegistration, didDeleteRegistration, didOpenRegistration, didCloseRegistration, didChangeRegistration);
    }
    _getDocument(uri) {
        const path = UriPaths_1.getUriPath(uri);
        const document = this.razorDocuments[path];
        if (!document) {
            throw new Error('Requested document does not exist.');
        }
        return document;
    }
    openDocument(uri) {
        const document = this._getDocument(uri);
        this.notifyDocumentChange(document, RazorDocumentChangeKind_1.RazorDocumentChangeKind.opened);
    }
    closeDocument(uri) {
        const document = this._getDocument(uri);
        const csharpDocument = document.csharpDocument;
        const csharpProjectedDocument = csharpDocument;
        const htmlDocument = document.htmlDocument;
        const htmlProjectedDocument = htmlDocument;
        const currentHtmlContent = htmlProjectedDocument.getContent();
        // Force the sync version back to null. VSCode resets all sync versions when a document closes.
        csharpProjectedDocument.update([], null);
        htmlProjectedDocument.setContent(currentHtmlContent, null);
        this.notifyDocumentChange(document, RazorDocumentChangeKind_1.RazorDocumentChangeKind.closed);
    }
    documentChanged(uri) {
        return __awaiter(this, void 0, void 0, function* () {
            const document = yield this._getDocument(uri);
            const activeTextEditor = vscode.window.activeTextEditor;
            if (activeTextEditor && activeTextEditor.document.uri === uri) {
                this.updateHtmlBuffer(document);
            }
        });
    }
    addDocument(uri) {
        const document = RazorDocumentFactory_1.createDocument(uri);
        this.razorDocuments[document.path] = document;
        this.notifyDocumentChange(document, RazorDocumentChangeKind_1.RazorDocumentChangeKind.added);
        return document;
    }
    removeDocument(uri) {
        const document = this._getDocument(uri);
        delete this.razorDocuments[document.path];
        this.notifyDocumentChange(document, RazorDocumentChangeKind_1.RazorDocumentChangeKind.removed);
    }
    updateCSharpBuffer(updateBufferRequest) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.logger.verboseEnabled) {
                this.logger.logVerbose(`Updating the C# document for Razor file '${updateBufferRequest.hostDocumentFilePath}' ` +
                    `(${updateBufferRequest.hostDocumentVersion})`);
            }
            const hostDocumentUri = vscode.Uri.file(updateBufferRequest.hostDocumentFilePath);
            const document = this._getDocument(hostDocumentUri);
            const projectedDocument = document.csharpDocument;
            if (!projectedDocument.hostDocumentSyncVersion ||
                projectedDocument.hostDocumentSyncVersion <= updateBufferRequest.hostDocumentVersion) {
                // We allow re-setting of the updated content from the same doc sync version in the case
                // of project or _ViewImport.cshtml changes.
                const csharpProjectedDocument = projectedDocument;
                csharpProjectedDocument.update(updateBufferRequest.changes, updateBufferRequest.hostDocumentVersion);
                this.notifyDocumentChange(document, RazorDocumentChangeKind_1.RazorDocumentChangeKind.csharpChanged);
            }
        });
    }
    updateHtmlBuffer(document) {
        const projectedDocument = document.htmlDocument;
        const hostDocument = vscode.workspace.textDocuments.find(doc => UriPaths_1.getUriPath(doc.uri).localeCompare(document.path, undefined, { sensitivity: 'base' }) === 0);
        if (hostDocument) {
            const hostDocumentText = hostDocument.getText();
            const htmlProjectedDocument = projectedDocument;
            htmlProjectedDocument.setContent(hostDocumentText, hostDocument.version);
            this.notifyDocumentChange(document, RazorDocumentChangeKind_1.RazorDocumentChangeKind.htmlChanged);
        }
    }
    notifyDocumentChange(document, kind) {
        if (this.logger.verboseEnabled) {
            this.logger.logVerbose(`Notifying docoument '${UriPaths_1.getUriPath(document.uri)}' changed '${RazorDocumentChangeKind_1.RazorDocumentChangeKind[kind]}'`);
        }
        const args = {
            document,
            kind,
        };
        this.onChangeEmitter.fire(args);
    }
    ensureProjectedDocumentsOpen(document) {
        return __awaiter(this, void 0, void 0, function* () {
            yield vscode.workspace.openTextDocument(document.csharpDocument.uri);
            yield vscode.workspace.openTextDocument(document.htmlDocument.uri);
        });
    }
}
exports.RazorDocumentManager = RazorDocumentManager;
//# sourceMappingURL=RazorDocumentManager.js.map