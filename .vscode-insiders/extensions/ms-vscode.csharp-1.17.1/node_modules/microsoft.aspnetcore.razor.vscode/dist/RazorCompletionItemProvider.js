"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const vscode = __importStar(require("vscode"));
const RazorLanguageFeatureBase_1 = require("./RazorLanguageFeatureBase");
const UriPaths_1 = require("./UriPaths");
class RazorCompletionItemProvider extends RazorLanguageFeatureBase_1.RazorLanguageFeatureBase {
    constructor(documentSynchronizer, documentManager, serviceClient, provisionalCompletionOrchestrator, logger) {
        super(documentSynchronizer, documentManager, serviceClient);
        this.provisionalCompletionOrchestrator = provisionalCompletionOrchestrator;
        this.logger = logger;
    }
    static getCompletions(projectedUri, hostDocumentPosition, projectedPosition, triggerCharacter) {
        return __awaiter(this, void 0, void 0, function* () {
            if (projectedUri) {
                const completions = yield vscode
                    .commands
                    .executeCommand('vscode.executeCompletionItemProvider', projectedUri, projectedPosition, triggerCharacter);
                const completionItems = completions instanceof Array ? completions // was vscode.CompletionItem[]
                    : completions ? completions.items // was vscode.CompletionList
                        : [];
                // There are times when the generated code will not line up with the content of the .cshtml file.
                // Therefore, we need to offset all completion items charactesr by a certain amount in order
                // to have proper completion. An example of this is typing @DateTime at the beginning of a line.
                // In the code behind it's represented as __o = DateTime.
                const completionCharacterOffset = projectedPosition.character - hostDocumentPosition.character;
                for (const completionItem of completionItems) {
                    if (completionItem.range) {
                        const rangeStart = new vscode.Position(hostDocumentPosition.line, completionItem.range.start.character - completionCharacterOffset);
                        const rangeEnd = new vscode.Position(hostDocumentPosition.line, completionItem.range.end.character - completionCharacterOffset);
                        completionItem.range = new vscode.Range(rangeStart, rangeEnd);
                    }
                    // textEdit is deprecated in favor of .range. Clear out its value to avoid any unexpected behavior.
                    completionItem.textEdit = undefined;
                }
                const isIncomplete = completions instanceof Array ? false
                    : completions ? completions.isIncomplete
                        : false;
                return new vscode.CompletionList(completionItems, isIncomplete);
            }
        });
    }
    provideCompletionItems(document, position, token, context) {
        return __awaiter(this, void 0, void 0, function* () {
            const projection = yield this.getProjection(document, position, token);
            if (this.logger.verboseEnabled) {
                this.logger.logVerbose(`Providing completions for document ${UriPaths_1.getUriPath(document.uri)} ` +
                    `at location (${position.line}, ${position.character})`);
            }
            if (!projection) {
                return { isIncomplete: true, items: [] };
            }
            const provisionalCompletions = yield this.provisionalCompletionOrchestrator.tryGetProvisionalCompletions(document.uri, projection, context);
            if (provisionalCompletions) {
                return provisionalCompletions;
            }
            // Not a provisional completion
            const completionList = yield RazorCompletionItemProvider.getCompletions(projection.uri, position, projection.position, context.triggerCharacter);
            return completionList;
        });
    }
}
exports.RazorCompletionItemProvider = RazorCompletionItemProvider;
//# sourceMappingURL=RazorCompletionItemProvider.js.map