"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = require("events");
const vscode = __importStar(require("vscode"));
const vscode_jsonrpc_1 = require("vscode-jsonrpc");
const main_1 = require("vscode-languageclient/lib/main");
const events = {
    ServerStart: 'ServerStart',
    ServerStop: 'ServerStop',
};
class RazorLanguageServerClient {
    constructor(options, telemetryReporter, logger) {
        this.telemetryReporter = telemetryReporter;
        this.logger = logger;
        this.isStarted = false;
        this.clientOptions = {
            outputChannel: options.outputChannel,
        };
        const args = [];
        let command = options.serverPath;
        if (options.serverPath.endsWith('.dll')) {
            this.logger.logMessage('Razor Language Server path is an assembly. ' +
                'Using \'dotnet\' from the current path to start the server.');
            command = 'dotnet';
            args.push(options.serverPath);
        }
        args.push('-lsp');
        args.push('--logLevel');
        const logLevelString = this.getLogLevelString(options.trace);
        this.telemetryReporter.reportTraceLevel(options.trace);
        args.push(logLevelString);
        if (options.debug) {
            this.telemetryReporter.reportDebugLanguageServer();
            this.logger.logMessage('Debug flag set for Razor Language Server.');
            args.push('--debug');
        }
        this.serverOptions = {
            run: { command, args },
            debug: { command, args },
        };
        this.client = new main_1.LanguageClient('razorLanguageServer', 'Razor Language Server', this.serverOptions, this.clientOptions);
        this.eventBus = new events_1.EventEmitter();
    }
    onStart(listener) {
        this.eventBus.addListener(events.ServerStart, listener);
        const disposable = new vscode.Disposable(() => this.eventBus.removeListener(events.ServerStart, listener));
        return disposable;
    }
    onStop(listener) {
        this.eventBus.addListener(events.ServerStop, listener);
        const disposable = new vscode.Disposable(() => this.eventBus.removeListener(events.ServerStop, listener));
        return disposable;
    }
    start() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                this.logger.logMessage('Starting Razor Language Server...');
                this.startDisposable = yield this.client.start();
                this.logger.logMessage('Server started, waiting for client to be ready...');
                yield this.client.onReady();
                this.logger.logMessage('Server started and ready!');
                this.isStarted = true;
                this.eventBus.emit(events.ServerStart);
            }
            catch (error) {
                vscode.window.showErrorMessage('Razor Language Server failed to start unexpectedly, ' +
                    'please check the \'Razor Log\' and report an issue.');
                this.telemetryReporter.reportErrorOnServerStart(error);
            }
        });
    }
    sendRequest(method, param) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.isStarted) {
                throw new Error('Tried to send requests while server is not started.');
            }
            return this.client.sendRequest(method, param);
        });
    }
    onRequest(method, handler) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.isStarted) {
                throw new Error('Tried to bind on request logic while server is not started.');
            }
            this.client.onRequest(method, handler);
        });
    }
    dispose() {
        this.logger.logMessage('Stopping Razor Language Server.');
        if (this.startDisposable) {
            this.startDisposable.dispose();
        }
        this.isStarted = false;
        this.eventBus.emit(events.ServerStop);
    }
    getLogLevelString(trace) {
        switch (trace) {
            case vscode_jsonrpc_1.Trace.Off:
                return 'None';
            case vscode_jsonrpc_1.Trace.Messages:
                return 'Information';
            case vscode_jsonrpc_1.Trace.Verbose:
                return 'Trace';
        }
        throw new Error(`Unexpected trace value: '${vscode_jsonrpc_1.Trace[trace]}'`);
    }
}
exports.RazorLanguageServerClient = RazorLanguageServerClient;
//# sourceMappingURL=RazorLanguageServerClient.js.map