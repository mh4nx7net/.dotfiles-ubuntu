"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs = __importStar(require("fs"));
const vscode = __importStar(require("vscode"));
const RazorProjectChangeKind_1 = require("./RazorProjectChangeKind");
const UriPaths_1 = require("./UriPaths");
const configurationFileGlobbingPath = `**/project.razor.json`;
const csprojGlobbingPath = `**/*.csproj`;
class RazorProjectManager {
    constructor(logger) {
        this.logger = logger;
        this.razorProjects = {};
        this.onChangeEmitter = new vscode.EventEmitter();
    }
    get onChange() { return this.onChangeEmitter.event; }
    initialize() {
        return __awaiter(this, void 0, void 0, function* () {
            // Track current projects
            const projectUris = yield vscode.workspace.findFiles(csprojGlobbingPath);
            for (const uri of projectUris) {
                this.addProject(uri);
            }
            const projectConfigurationUris = yield vscode.workspace.findFiles(configurationFileGlobbingPath);
            for (const configurationUri of projectConfigurationUris) {
                this.updateProjectConfiguration(configurationUri);
            }
        });
    }
    register() {
        // Track future projects
        const projectWatcher = vscode.workspace.createFileSystemWatcher(csprojGlobbingPath);
        const didCreateRegistration = projectWatcher.onDidCreate((uri) => __awaiter(this, void 0, void 0, function* () { return this.addProject(uri); }));
        const didDeleteRegistration = projectWatcher.onDidDelete((uri) => __awaiter(this, void 0, void 0, function* () { return this.removeProject(uri); }));
        // Track future projects data files
        const configurationWatcher = vscode.workspace.createFileSystemWatcher(configurationFileGlobbingPath);
        const didCreateConfigRegistration = configurationWatcher.onDidCreate((uri) => __awaiter(this, void 0, void 0, function* () { return this.updateProjectConfiguration(uri); }));
        const didDeleteConfigRegistration = configurationWatcher.onDidDelete((uri) => __awaiter(this, void 0, void 0, function* () { return this.removeProjectConfiguration(uri); }));
        const didChangeConfigRegistration = configurationWatcher.onDidChange((uri) => __awaiter(this, void 0, void 0, function* () { return this.updateProjectConfiguration(uri); }));
        return vscode.Disposable.from(configurationWatcher, didCreateRegistration, didDeleteRegistration, didCreateConfigRegistration, didDeleteConfigRegistration, didChangeConfigRegistration);
    }
    updateProjectConfiguration(configurationUri) {
        const configuration = this.getProjectConfiguration(configurationUri);
        if (!configuration) {
            return;
        }
        if (!this.razorProjects[configuration.projectPath]) {
            this.logger.logVerbose(`Invalid project config. Could not find a corresponding project for ${configuration.projectPath}`);
            return;
        }
        const projectContainer = this._getProject(configuration.projectUri);
        const newProject = {
            uri: projectContainer.uri,
            path: projectContainer.path,
            configuration,
        };
        this.razorProjects[newProject.path] = newProject;
        this.notifyProjectChange(newProject, RazorProjectChangeKind_1.RazorProjectChangeKind.changed);
    }
    removeProjectConfiguration(uri) {
        const projectDataPath = UriPaths_1.getUriPath(uri);
        const projects = Object.values(this.razorProjects);
        let containingProject;
        for (const project of projects) {
            if (project.configuration && project.configuration.path === projectDataPath) {
                containingProject = project;
                break;
            }
        }
        if (!containingProject) {
            // Deleted an untracked project.razor.json file, noop.
            return;
        }
        const newProject = {
            uri: containingProject.uri,
            path: containingProject.path,
        };
        this.razorProjects[newProject.path] = newProject;
        this.notifyProjectChange(newProject, RazorProjectChangeKind_1.RazorProjectChangeKind.changed);
    }
    addProject(uri) {
        const project = this.createDefaultProject(uri);
        this.razorProjects[project.path] = project;
        this.notifyProjectChange(project, RazorProjectChangeKind_1.RazorProjectChangeKind.added);
        return project;
    }
    removeProject(uri) {
        const project = this._getProject(uri);
        delete this.razorProjects[project.path];
        this.notifyProjectChange(project, RazorProjectChangeKind_1.RazorProjectChangeKind.removed);
    }
    _getProject(uri) {
        const path = UriPaths_1.getUriPath(uri);
        const project = this.razorProjects[path];
        if (!project) {
            throw new Error('Requested project does not exist.');
        }
        return project;
    }
    notifyProjectChange(project, kind) {
        if (this.logger.verboseEnabled) {
            this.logger.logVerbose(`Notifying project '${UriPaths_1.getUriPath(project.uri)}' - '${RazorProjectChangeKind_1.RazorProjectChangeKind[kind]}'`);
        }
        const args = {
            project,
            kind,
        };
        this.onChangeEmitter.fire(args);
    }
    getProjectConfiguration(uri) {
        const fileSystemPath = uri.fsPath || uri.path;
        try {
            const path = UriPaths_1.getUriPath(uri);
            const projectJson = fs.readFileSync(fileSystemPath, 'utf8');
            const lastUpdated = fs.statSync(fileSystemPath).mtime;
            const projectParsed = JSON.parse(projectJson);
            const projectUri = vscode.Uri.file(projectParsed.ProjectFilePath);
            const projectFilePath = UriPaths_1.getUriPath(projectUri);
            const configuration = {
                uri,
                path,
                projectPath: projectFilePath,
                projectUri,
                configuration: projectParsed.Configuration,
                tagHelpers: projectParsed.TagHelpers,
                targetFramework: projectParsed.TargetFramework,
                lastUpdated,
            };
            return configuration;
        }
        catch (error) {
            this.logger.logError(`Failed to read project config at location ${fileSystemPath}: ${error}`);
        }
        return undefined;
    }
    createDefaultProject(uri) {
        const path = UriPaths_1.getUriPath(uri);
        const project = {
            uri,
            path,
        };
        return project;
    }
}
exports.RazorProjectManager = RazorProjectManager;
//# sourceMappingURL=RazorProjectManager.js.map