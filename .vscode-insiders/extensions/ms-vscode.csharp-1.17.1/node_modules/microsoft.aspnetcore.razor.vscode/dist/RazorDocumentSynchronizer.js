"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const vscode = __importStar(require("vscode"));
const CSharpProjectedDocumentContentProvider_1 = require("./CSharp/CSharpProjectedDocumentContentProvider");
const HtmlProjectedDocumentContentProvider_1 = require("./Html/HtmlProjectedDocumentContentProvider");
const RazorDocumentChangeKind_1 = require("./RazorDocumentChangeKind");
const UriPaths_1 = require("./UriPaths");
class RazorDocumentSynchronizer {
    constructor(documentManager, logger) {
        this.documentManager = documentManager;
        this.logger = logger;
        this.synchronizations = {};
        this.synchronizationIdentifier = 0;
    }
    register() {
        const documentManagerRegistration = this.documentManager.onChange(event => this.documentChanged(event));
        const textDocumentChangeRegistration = vscode.workspace.onDidChangeTextDocument(event => this.textDocumentChanged(event));
        return vscode.Disposable.from(documentManagerRegistration, textDocumentChangeRegistration);
    }
    trySynchronizeProjectedDocument(hostDocument, projectedDocument, expectedHostDocumentVersion, token) {
        return __awaiter(this, void 0, void 0, function* () {
            const logId = ++this.synchronizationIdentifier;
            const documentKey = UriPaths_1.getUriPath(projectedDocument.uri);
            if (this.logger.verboseEnabled) {
                const ehdv = expectedHostDocumentVersion;
                this.logger.logVerbose(`${logId} - Synchronizing '${documentKey}':
    Currently at ${projectedDocument.hostDocumentSyncVersion}, synchronizing to version '${ehdv}'.
    Current host document version: '${hostDocument.version}'
    Current projected document version: '${projectedDocument.projectedDocumentSyncVersion}'`);
            }
            if (hostDocument.version !== expectedHostDocumentVersion) {
                if (this.logger.verboseEnabled) {
                    this.logger.logVerbose(`${logId} - toHostDocumentVersion and hostDocument.version already out of date.`);
                }
                // Already out-of-date. Allowing synchronizations for now to see if this actually causes any issues.
            }
            const context = this.createSynchronizationContext(documentKey, projectedDocument, expectedHostDocumentVersion, hostDocument, token);
            try {
                if (projectedDocument.hostDocumentSyncVersion !== expectedHostDocumentVersion) {
                    if (this.logger.verboseEnabled) {
                        this.logger.logVerbose(`${logId} - Projected document not in sync with host document, waiting for update...
    Current host document sync version: ${projectedDocument.hostDocumentSyncVersion}`);
                    }
                    yield context.onProjectedDocumentSynchronized;
                }
                if (this.logger.verboseEnabled) {
                    this.logger.logVerbose(`${logId} - Projected document in sync with host document`);
                }
                // Projected document is the one we expect.
                const projectedTextDocument = yield vscode.workspace.openTextDocument(projectedDocument.uri);
                const projectedTextDocumentVersion = this.getProjectedTextDocumentVersion(projectedTextDocument);
                if (projectedDocument.projectedDocumentSyncVersion !== projectedTextDocumentVersion) {
                    if (this.logger.verboseEnabled) {
                        this.logger.logVerbose(`${logId} - Projected text document not in sync with data type, waiting for update...
    Current projected text document sync version: ${projectedTextDocumentVersion}`);
                    }
                    yield context.onProjectedTextDocumentSynchronized;
                }
                if (this.logger.verboseEnabled) {
                    this.logger.logVerbose(`${logId} - Projected text document in sync with data type`);
                }
                // Projected text document is the one we expect
            }
            catch (cancellationReason) {
                this.removeSynchronization(context);
                if (this.logger.verboseEnabled) {
                    this.logger.logVerbose(`${logId} - Synchronization failed: ${cancellationReason}`);
                }
                return false;
            }
            this.removeSynchronization(context);
            if (this.logger.verboseEnabled) {
                this.logger.logVerbose(`${logId} - Synchronization successful!`);
            }
            return true;
        });
    }
    removeSynchronization(context) {
        const documentKey = UriPaths_1.getUriPath(context.projectedDocument.uri);
        const synchronizations = this.synchronizations[documentKey];
        clearTimeout(context.timeoutId);
        if (synchronizations.length === 1) {
            delete this.synchronizations[documentKey];
            return;
        }
        this.synchronizations[documentKey] = synchronizations.filter(item => item !== context);
    }
    createSynchronizationContext(documentKey, projectedDocument, toHostDocumentVersion, hostDocument, token) {
        const rejectionsForCancel = [];
        let projectedDocumentSynchronized = Function;
        const onProjectedDocumentSynchronized = new Promise((resolve, reject) => {
            projectedDocumentSynchronized = resolve;
            rejectionsForCancel.push(reject);
        });
        let projectedTextDocumentSynchronized = Function;
        const onProjectedTextDocumentSynchronized = new Promise((resolve, reject) => {
            projectedTextDocumentSynchronized = resolve;
            rejectionsForCancel.push(reject);
        });
        token.onCancellationRequested((reason) => {
            context.cancel(`Token cancellation requested: ${reason}`);
        });
        const timeoutId = setTimeout(() => {
            context.cancel('Synchronization timed out');
        }, 2000);
        const context = {
            projectedDocument,
            logIdentifier: this.synchronizationIdentifier,
            timeoutId,
            toHostDocumentVersion,
            hostDocumentVersion: hostDocument.version,
            cancel: (reason) => {
                for (const reject of rejectionsForCancel) {
                    reject(reason);
                }
            },
            projectedDocumentSynchronized,
            onProjectedDocumentSynchronized,
            projectedTextDocumentSynchronized,
            onProjectedTextDocumentSynchronized,
        };
        let synchronizations = this.synchronizations[documentKey];
        if (!synchronizations) {
            synchronizations = [];
            this.synchronizations[documentKey] = synchronizations;
        }
        synchronizations.push(context);
        return context;
    }
    textDocumentChanged(event) {
        if (event.document.uri.scheme !== CSharpProjectedDocumentContentProvider_1.CSharpProjectedDocumentContentProvider.scheme &&
            event.document.uri.scheme !== HtmlProjectedDocumentContentProvider_1.HtmlProjectedDocumentContentProvider.scheme) {
            return;
        }
        const projectedTextDocumentVersion = this.getProjectedTextDocumentVersion(event.document);
        if (projectedTextDocumentVersion === null) {
            return;
        }
        const documentKey = UriPaths_1.getUriPath(event.document.uri);
        const synchronizationContexts = this.synchronizations[documentKey];
        if (!synchronizationContexts) {
            return;
        }
        for (const context of synchronizationContexts) {
            if (context.projectedDocument.projectedDocumentSyncVersion === projectedTextDocumentVersion) {
                if (this.logger.verboseEnabled) {
                    const li = context.logIdentifier;
                    const ptdv = projectedTextDocumentVersion;
                    this.logger.logVerbose(`${li} - Projected text document synchronized to ${ptdv}.`);
                }
                context.projectedTextDocumentSynchronized();
            }
        }
    }
    documentChanged(event) {
        let projectedDocument;
        if (event.kind === RazorDocumentChangeKind_1.RazorDocumentChangeKind.csharpChanged) {
            projectedDocument = event.document.csharpDocument;
        }
        else if (event.kind === RazorDocumentChangeKind_1.RazorDocumentChangeKind.htmlChanged) {
            projectedDocument = event.document.htmlDocument;
        }
        else {
            return;
        }
        const hostDocumentSyncVersion = projectedDocument.hostDocumentSyncVersion;
        if (hostDocumentSyncVersion === null) {
            return;
        }
        const documentKey = UriPaths_1.getUriPath(projectedDocument.uri);
        const synchronizationContexts = this.synchronizations[documentKey];
        if (!synchronizationContexts) {
            return;
        }
        for (const context of synchronizationContexts) {
            if (context.toHostDocumentVersion === projectedDocument.hostDocumentSyncVersion) {
                context.projectedDocumentSynchronized();
            }
        }
    }
    getProjectedTextDocumentVersion(textDocument) {
        // Logic defined in this method is heavily dependent on the functionality in the projected
        // document content providers to append versions to the end of text documents.
        if (textDocument.lineCount <= 0) {
            return null;
        }
        const lastLine = textDocument.lineAt(textDocument.lineCount - 1);
        const versionString = lastLine.text.substring(3 /* //_ */);
        const textDocumentProjectedVersion = parseInt(versionString, 10);
        return textDocumentProjectedVersion;
    }
}
exports.RazorDocumentSynchronizer = RazorDocumentSynchronizer;
//# sourceMappingURL=RazorDocumentSynchronizer.js.map